name: E2E Test

on:
  schedule:
    - cron: '00 03 * * *'
  workflow_dispatch: # Allow manual triggering
    inputs:
      operator_version:
        description: 'Operator version/tag (e.g., edge, x.y.z)'
        required: false
        default: 'edge'
        type: string
  workflow_call: # Allow being called by other workflows
    inputs:
      operator_version:
        description: 'Operator version/tag (e.g., edge, x.y.z)'
        required: false
        default: 'edge'
        type: string

env:
  OPERATOR_VERSION: ${{ inputs.operator_version || 'edge' }}

concurrency:
  group: ${{ github.ref_name }}-e2e
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  e2e-test:
    name: End-to-End Test
    runs-on: ubuntu-24.04
    steps:
      - name: Checkout Repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Check if image exists
        id: image_exists
        run: |
          exists=false
          if docker pull nginx/nginx-ingress-operator:${{ env.OPERATOR_VERSION }}; then
            exists=true
          fi
          echo "exists=${exists}" >> $GITHUB_OUTPUT

      - name: Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0
        if: steps.image_exists.outputs.exists == 'false'

      - name: Build Image
        uses: docker/build-push-action@10e90e3645eae34f1e60eeb005ba3a3d33f178e8 # v6.19.2
        with:
          context: "."
          cache-from: type=gha
          cache-to: type=gha,mode=max
          tags: nginx/nginx-ingress-operator:${{ env.OPERATOR_VERSION }}
          platforms: ${{ github.event_name != 'pull_request' && env.platforms || '' }}
          load: true
          push: false
          no-cache: ${{ github.event_name != 'pull_request' }}
          pull: true
          sbom: false
          provenance: false
        if: steps.image_exists.outputs.exists == 'false'

      - name: Get Latest Versions
        run: |
          # Get latest supported Kubernetes version from Minikube
          # Handle both old format "Support Kubernetes version vX.Y.Z" and new format "Support for Kubernetes vX.Y.Z"
          K8S_VERSION=$(curl -s https://api.github.com/repos/kubernetes/minikube/releases/latest | jq -r '.body' | grep -oE "(Support for Kubernetes|Support Kubernetes version) v[0-9]+\.[0-9]+\.[0-9]+" | grep -o "[0-9]\+\.[0-9]\+\.[0-9]\+" | head -1)
          
          # Fallback to a known stable Kubernetes version if extraction fails
          if [ -z "$K8S_VERSION" ]; then
            echo "Warning: Could not extract Kubernetes version from Minikube release notes, using fallback version 1.34.0"
            K8S_VERSION="1.34.0"
          fi
          
          echo "KUBERNETES_VERSION=v$K8S_VERSION" >> $GITHUB_ENV
          
          # Get latest Minikube version
          echo "MINIKUBE_VERSION=$(curl -s https://api.github.com/repos/kubernetes/minikube/releases/latest | jq -r '.tag_name')" >> $GITHUB_ENV

      - name: Install kubectl
        run: |
          curl -LO "https://dl.k8s.io/release/${{ env.KUBERNETES_VERSION }}/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/

      - name: Install Minikube
        run: |
          curl -Lo minikube https://storage.googleapis.com/minikube/releases/${{ env.MINIKUBE_VERSION }}/minikube-linux-amd64
          chmod +x minikube
          sudo mv minikube /usr/local/bin/

      - name: Start Minikube
        run: |
          minikube start --kubernetes-version=${{ env.KUBERNETES_VERSION }} --driver=docker --memory=4g --cpus=2
          minikube image load nginx/nginx-ingress-operator:${{ env.OPERATOR_VERSION }}

      - name: Verify Kubernetes cluster
        run: |
          kubectl cluster-info
          kubectl get nodes
          kubectl get pods -A

      - name: Deploy NGINX Ingress Operator
        run: |
          # Deploy the operator using make deploy with specified version, edge otherwise
          make deploy IMG=nginx/nginx-ingress-operator:${{ env.OPERATOR_VERSION }}
          
          # Wait for the operator to be ready
          kubectl wait --for=condition=Available --timeout=300s deployment/nginx-ingress-operator-controller-manager -n nginx-ingress-operator-system

      - name: Verify Operator Deployment
        run: |
          # Check operator deployment status
          kubectl get deployments -n nginx-ingress-operator-system
          kubectl get pods -n nginx-ingress-operator-system
          
          # Check operator logs
          kubectl logs -l control-plane=controller-manager -n nginx-ingress-operator-system --tail=50

      - name: Deploy Example NGINX Ingress Controller
        run: |
          # Create the namespace and NGINX Ingress Controller instance in namespace nginx-ingress
          kubectl create namespace nginx-ingress
          kubectl apply -f tests/nginx-ingress-controller-oss.yaml
          
          # Wait for the operator to process and install the Helm release
          echo "Waiting for operator to install Helm release..."
          sleep 30
          
          # Check what deployments were actually created
          echo "Checking deployments in nginx-ingress namespace:"
          kubectl get deployments -n nginx-ingress
          
          # Find the actual deployment name
          DEPLOYMENT_NAME=$(kubectl get deployments -n nginx-ingress -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          
          if [ -z "$DEPLOYMENT_NAME" ]; then
            echo "No deployment found, waiting longer..."
            sleep 30
            kubectl get deployments -n nginx-ingress
            DEPLOYMENT_NAME=$(kubectl get deployments -n nginx-ingress -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || echo "")
          fi
          
          if [ -n "$DEPLOYMENT_NAME" ]; then
            echo "Found deployment: $DEPLOYMENT_NAME"
            # Export for use in subsequent steps
            echo "DEPLOYMENT_NAME=$DEPLOYMENT_NAME" >> $GITHUB_ENV
            # Wait for the NGINX Ingress Controller to be ready
            kubectl wait --for=condition=Available --timeout=300s deployment/$DEPLOYMENT_NAME -n nginx-ingress
          else
            echo "Failed to find any deployment in nginx-ingress namespace"
            exit 1
          fi
      - name: Verify NGINX Ingress Controller Deployment
        run: |
          # Check all resources in the nginx ingress controller namespace
          kubectl get all -n nginx-ingress
          
          # Check if the controller pod is running
          kubectl get pods -n nginx-ingress 
          
          # Check the service
          kubectl get services -n nginx-ingress
          
          # Check ingress class
          kubectl get ingressclass
          
          # Verify all pods are ready in nginx-ingress namespace
          kubectl wait --for=condition=Ready --timeout=300s pod --all -n nginx-ingress

      - name: Verify NGINX Configuration
        run: |
          echo "Testing NGINX configuration for deployment: $DEPLOYMENT_NAME"
          
          # Check NGINX configuration is valid
          kubectl exec -n nginx-ingress deployment/$DEPLOYMENT_NAME -- nginx -t

      - name: Check Operator and Controller Logs
        if: always()
        run: |
          echo "=== Operator Logs ==="
          kubectl logs -l control-plane=controller-manager -n nginx-ingress-operator-system
          
          echo "=== NGINX Ingress Controller Logs ==="
          # Get logs from all pods in nginx-ingress namespace
          for pod in $(kubectl get pods -n nginx-ingress -o jsonpath='{.items[*].metadata.name}' 2>/dev/null || echo ""); do
            if [ -n "$pod" ]; then
              echo "--- Logs for pod: $pod ---"
              kubectl logs $pod -n nginx-ingress
            fi
          done
